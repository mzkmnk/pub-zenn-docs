---
title: "SOLID原則について"
emoji: "🐡"
type: "tech"
topics: ["SOLID原則"]
published: false
---

## SOLID原則とは？
ソフトウェアエンジニアの[Robert C. Martin](https://en.wikipedia.org/wiki/Robert_C._Martin)が提唱した**オブジェクト指向において大切な5つのルール**です。

5つのルール
1. **S** 単一責任の原則(Single-responsibility Principle)
2. **O** オープン・クローズドの原則(Open-closed Principle)
3. **L** リスコフの置換原則(Liskov Substitution Principle)
4. **I** インターフェース分離の原則(Interface Segregation Principle)
5. **D** 依存関係逆転の法則(Dependency Inversion Principle)

これらの頭文字をとって**SOLID**原則と言われています。

これを守ることでメンテナンス可能になる、つまり長期的にそのコードが保守され続けて行きます。
今回はtypescriptを用いて例を用いながら解説(自分の学んだこと)をしていきます。

## 単一責任の原則(Single-responsibility Principle)

> 変更する理由が、一つのクラスに対して一つ以上あってはいけない。

クラスの責任は単一であるべき、という原則です。

下記コードをご覧ください。

悪い例

```ts
class User {

  constructor(name:string) {
  }

  setUserName(name: string) {
    this.name = name;
    this.saveUserName(this.name);
  }

  saveUserName(name: string) { /** ロジック */}
}
```

上記コードだとUserクラスが

- DBに名前を保存する
- 名前を更新する

という2つの役割を持っています。

この場合

- DBに保存する処理内容が変更された
- 名前を更新するロジックを変えて欲しい

という2つにおいてこのクラスが変更される可能性があります。

そのため下記のようなコードに分割します。

良い例
```ts

class UserDB {
  save(name:string) { /** ロジック */ }
}

class User {
  constructor(
    name:string,
    private userDB:UserDB
  ) {
  }

  setUserName(name: string) {
    this.name = name;
    this.userDB.save(this.name);
  }
}
```

上記のように分割することで、コードの可読性が高まりそれぞれの役割が明確化します。

## オープン・クローズドの原則(Open-closed Principle)

> ソフトウェアの実体（クラス、モジュール、関数など）は、拡張に対して開かれているべきであり、修正に対して閉じていなければならない

## リスコフの置換原則(Liskov Substitution Principle)

> ある基底クラスへのポインタないし参照を扱っている関数群は、その派生クラスのオブジェクトの詳細を知らなくても扱えるようにしなければならない

サブタイプは、そのスーパータイプと置き換えが可能である、つまり置換可能でなければならない、という原則です。

基本的に実装継承を起こっている場合、この違反をすることがあります。

下記コードをご覧ください。

悪い例

```ts
import number = CSS.number;

class Rectangle {
  constructor(width: number, height: number) {
  }

  setWidth(width: number) {
    this.width = width;
  }

  setHeight(height: number) {
    this.height = height;
  }

  area(): number {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  setWidth(width: number) {
    super.setWidth(width);
    super.setHeight(width);
  }

  setHeight(height: number) {
    super.setWidth(height);
    super.setHeight(height);
  }
}

// クライアント側でのテスト関数
function Testing(rect: Rectangle) {
  const beforeArea = rect.area();

  rect.setWidth(rect.width * 2);

  if (rect.area() !== beforeArea * 2) {
    throw new Error('面積が2倍になりませんでした。', beforeArea, rect.area());
  }

  console.log('問題ないです。');
}

// テストコード

Testing(new Rectangle(4, 5)); // log: 問題ないです。
Testinr(new Square(4, 4)); // log: 面積が2倍になりませんでした。 16,64;
```

上記のコードでは、`Rectangle`を`Square`を継承しています。
この時、`Rectangle`の`setWidth`と`Square`の`setWidth`で振る舞いが変わってしまっています。
そのため、クライアント側で`height`や`width`に意図しない変更が入ってしまいます。

良い例

```ts
interface Shape {
  area(): number;
}

class Rectangle implements Shape {

  constructor(width: number, height: number) {
  }

  setWidth(width: number) {
    this.width = width;
  }

  setHeight(height: number) {
    this.height = height;
  }

  area(): number {
    return this.width * this.height;
  }
}

class Square implements Shape {

  constructor(side:number) {
  }

  setSide(side: number) {
    this.side = side;
  }

  area(): number {
    return this.side * this.side;
  }
}
```

上記のようにすることで,`Rectangle`、`Square`は`Shape`の振る舞いを守ることでリスコフの置換原則を守っています。
このようにすることで、既存コードを考えずに新規コードを追加できたり、スーパークラスの振る舞いさえ理解すればサブクラスの振る舞いを知らずとも使えるようになります。

## インターフェース分離の原則(Interface Segregation Principle)

> 汎用なインターフェースが一つあるよりも、各クライアントに特化したインターフェースがたくさんあった方がよい

上記の通りですね。インターフェースにあるプロパティを使わないクラアントは存在してはいけない、という原則です。

下記コードをご覧ください。

悪い例
```ts
// インターフェースを定義
interface Printer {
  print():void;
  scan():void;
  fax():void;
}

// 複数の機能を持ったプリンター
class MultiplePrinter implements Printer {
  print() { /** ロジック */ }
  
  scan() { /** ロジック */ }
  
  fax() { /** ロジック */ }
}

// 1つの機能を持ったプリンター
class BasicPrinter implements Printer {
  print() { /** ロジック */ }

  scan() { 
    throw new Error('この機能は使えません')
  }

  fax() {
    throw new Error('この機能は使えません')
  }
}

```

このコードでは、複数の機能を持った`MultiplePrinter`は`Printer`で定義した関数を全て使うので良いですが、`BasicPrinter`は`print`関数しか使いません。
ただ`scan`関数や、`fax`関数も実装する必要があるので使わないのに定義する必要が出てきています。
そのため`scan`関数の仕様に変更があった、例えば、引数を取るように仕様が変わった場合など、使っていないのに`BasicPrinter`まで修正する必要が出てきてしまいます。

良い例
```ts
//　それぞれの関数をインターフェースとして定義
interface Printable { print(): void; }
interface Scannable { scan(): void; }
interface Faxable   { fax(): void; }

// 複数の機能を持ったプリンター
class MultiplePrinter implements Printable, Scannable, Faxable {
  print() { /** ロジック */ }

  scan() { /** ロジック */ }

  fax() { /** ロジック */ }
}

// 1つの機能を持ったプリンター
class BasicPrinter implements Printable {
  print() { /** ロジック */ }
}
```

それぞれの役割を持ったインターフェースを定義することで、不必要なコードを書くことがなくなり**インターフェースの変更**にも強くなります。

## 依存関係逆転の法則(Dependency Inversion Principle)

> 上位のモジュールは下位のモジュールに依存してはならない。どちらのモジュールも「抽象」に依存すべきである 「抽象」は実装の詳細に依存してはならない。実装の詳細が「抽象」に依存すべきである

一言で言うと、上位モジュール、位モジュールどちらも抽象に依存しなさい、という原則です。

下記コードをご覧ください。

悪い例
```ts
// 下位モジュール
class EmailService {
  send(to: string, msg: string) { /** ロジック */ }
}

// 上位モジュール
class UserNotifier {
  
  private email = new EmailService();
  
  welcome(user: string) {
    this.email.send(user, "Welcome!");
  }
}

// クライアントコード
const user = new UserNotifier();
```

上記コードの場合、`UserNotifier`が`EmailService`という具象クラスに依存しています。
この場合、`UserNotifier`を利用するクライアントが複数いた場合どうなるでしょうか？

- AさんはEmailで送信したい。
- BさんはSlackで送信したい。

この場合、UserNotifierは変更できないので、新しく`UserNotifierWithSlack`みたいなものを作成する必要が出てきます。
こうなると同じようなロジックをしたものが複数存在しコードの可読性、保守性が著しく低下します。

```ts
class EmailService {
  send(to: string, msg: string) { /** ロジック */ }
}

class UserNotifierWithEmail {
  
  private email = new EmailService();
  
  welcome(user: string) {
    this.email.send(user, "Welcome!");
  }
}

class SlackService {
  send(to: string, msg: string) { /** ロジック */ }
}

class UserNotifierWithSlack {

  private email = new EmailService();

  welcome(user: string) {
    this.email.send(user, "Welcome!");
  }
}

// クライアントコード
const userA = UserNotifierWithEmail();

const userB = UserNotifierWithSlack();

```

良い例

```ts
// メッセージサービスを抽象化、インターフェースを作成
interface MessageSender {
  send(to: string, msg: string): void;
}

// クラスでインターフェースを実装
class EmailService implements MessageSender {
  send(to: string, msg: string) { /** ロジック */ }
}

class SlackService implements MessageSender {
  send(to: string, msg: string) { /** ロジック */ }
}

class UserNotifier {

  constructor(private sender:MessageSender) {
  }

  welcome(user: string) {
    this.sender.send(user, "Welcome!");
  }
}

// クライアントコード
const userA = new UserNotifier(new EmailService());
const userB = new UserNotifier(new SlackService());
```

上記のように、することで上位モジュールと下位モジュールが抽象に依存しているため、コードの差し替えが容易になる。